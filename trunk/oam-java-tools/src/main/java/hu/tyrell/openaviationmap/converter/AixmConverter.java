/*
    Open Aviation Map
    Copyright (C) 2012 Ákos Maróy

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package hu.tyrell.openaviationmap.converter;

import hu.tyrell.openaviationmap.model.Airspace;
import hu.tyrell.openaviationmap.model.Boundary;
import hu.tyrell.openaviationmap.model.Circle;
import hu.tyrell.openaviationmap.model.Point;
import hu.tyrell.openaviationmap.model.Ring;

import java.text.SimpleDateFormat;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.TimeZone;
import java.util.Vector;

import javax.xml.bind.JAXBElement;

import net.opengis.gml._3.AbstractRingPropertyType;
import net.opengis.gml._3.CircleByCenterPointType;
import net.opengis.gml._3.CodeWithAuthorityType;
import net.opengis.gml._3.CurvePropertyType;
import net.opengis.gml._3.CurveSegmentArrayPropertyType;
import net.opengis.gml._3.CurveType;
import net.opengis.gml._3.DirectPositionListType;
import net.opengis.gml._3.DirectPositionType;
import net.opengis.gml._3.GeodesicStringType;
import net.opengis.gml._3.LengthType;
import net.opengis.gml._3.PolygonPatchType;
import net.opengis.gml._3.RingType;
import net.opengis.gml._3.SurfacePatchArrayPropertyType;
import net.opengis.gml._3.TimeIndeterminateValueType;
import net.opengis.gml._3.TimePeriodType;
import net.opengis.gml._3.TimePositionType;
import net.opengis.gml._3.TimePrimitivePropertyType;
import aero.aixm.schema._5.AirspaceActivationPropertyType;
import aero.aixm.schema._5.AirspaceActivationType;
import aero.aixm.schema._5.AirspaceGeometryComponentPropertyType;
import aero.aixm.schema._5.AirspaceGeometryComponentType;
import aero.aixm.schema._5.AirspaceTimeSlicePropertyType;
import aero.aixm.schema._5.AirspaceTimeSliceType;
import aero.aixm.schema._5.AirspaceType;
import aero.aixm.schema._5.AirspaceVolumePropertyType;
import aero.aixm.schema._5.AirspaceVolumeType;
import aero.aixm.schema._5.CodeAirspaceActivityType;
import aero.aixm.schema._5.CodeAirspaceDesignatorType;
import aero.aixm.schema._5.CodeAirspaceType;
import aero.aixm.schema._5.CodeDayType;
import aero.aixm.schema._5.CodeMilitaryOperationsType;
import aero.aixm.schema._5.CodeNotePurposeType;
import aero.aixm.schema._5.CodeTimeReferenceType;
import aero.aixm.schema._5.CodeVerticalReferenceType;
import aero.aixm.schema._5.CodeYesNoType;
import aero.aixm.schema._5.LinguisticNotePropertyType;
import aero.aixm.schema._5.LinguisticNoteType;
import aero.aixm.schema._5.NotePropertyType;
import aero.aixm.schema._5.NoteType;
import aero.aixm.schema._5.SurfacePropertyType;
import aero.aixm.schema._5.SurfaceType;
import aero.aixm.schema._5.TextNameType;
import aero.aixm.schema._5.TextNoteType;
import aero.aixm.schema._5.TimeType;
import aero.aixm.schema._5.TimesheetPropertyType;
import aero.aixm.schema._5.TimesheetType;
import aero.aixm.schema._5.ValDistanceVerticalType;
import aero.aixm.schema._5_1.message.AIXMBasicMessageType;
import aero.aixm.schema._5_1.message.BasicMessageMemberAIXMPropertyType;

/**
 * Class to convert aviation data into AIXM.
 */
public final class AixmConverter {
    /**
     * A GML object factory, used to create GML related objects.
     */
    private static net.opengis.gml._3.ObjectFactory gmlFactory =
                                        new net.opengis.gml._3.ObjectFactory();
    /**
     * An AIXM object factory, generated by JAXB, used to create AIXM
     * related objects.
     */
    private static aero.aixm.schema._5.ObjectFactory aixmFactory =
                                        new aero.aixm.schema._5.ObjectFactory();

    /**
     * An AIXM message object factory, generated by JAXB, used to create AIXM
     * related objects.
     */
    private static aero.aixm.schema._5_1.message.ObjectFactory
        aixmMessageFactory = new aero.aixm.schema._5_1.message.ObjectFactory();

    /**
     * The date formatter to format validity dates.
     */
    private static SimpleDateFormat dateFormatter =
                        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");

    /**
     * Private default constructor.
     */
    private AixmConverter() {
    }

    /**
     * Convert a set of aerial information into an AIXM message document.
     *
     * @param airspaces the airspaces to convert
     * @param messageId the unique id of the generated AIXM message
     * @param codeSpace the code space to use when generating ids.
     * @param validStart the beginning of the validity period for the
     *        aerospace features. if null, this is unknown.
     * @param validEnd the end of the validity period for the
     *        aerospace features. if null, this is unknown.
     * @param interpretation the AIXM time slice interpretation to set.
     *        if in doubt, use "BASELINE"
     * @param sequence the AIXM time slice sequence number,
     *        if in doubt, specify 1
     * @param correction the AIXM time slice correction number,
     *        if in doubt, use  0
     * @return an AIXM message containing the supplied aerial resources
     */
    public static JAXBElement<AIXMBasicMessageType>
    convertToAixm(List<Airspace>     airspaces,
                  String             messageId,
                  String             codeSpace,
                  GregorianCalendar  validStart,
                  GregorianCalendar  validEnd,
                  String             interpretation,
                  long               sequence,
                  long               correction) {

        List<AirspaceType> aixmAirspaces = new Vector<AirspaceType>();

        airspacesToAixm(airspaces,
                        codeSpace,
                        validStart,
                        validEnd,
                        interpretation,
                        sequence,
                        correction,
                        aixmAirspaces);

        AIXMBasicMessageType message =
                              aixmMessageFactory.createAIXMBasicMessageType();

        for (AirspaceType apt : aixmAirspaces) {
            JAXBElement<AirspaceType> e = aixmFactory.createAirspace(apt);

            BasicMessageMemberAIXMPropertyType p =
                aixmMessageFactory.createBasicMessageMemberAIXMPropertyType();
            p.setAbstractAIXMFeature(e);

            message.getHasMember().add(p);
        }

        JAXBElement<AIXMBasicMessageType> m =
                            aixmMessageFactory.createAIXMBasicMessage(message);
        m.getValue().setId(messageId);

        return m;
    }

    /**
     * Convert a single airspace into an AIXM airspace.
     *
     * @param airspace the airspace to convert
     * @param codeSpace the code space to use when generating ids.
     * @param validStart the beginning of the validity period for the
     *        aerospace features. if null, this is unknown.
     * @param validEnd the end of the validity period for the
     *        aerospace features. if null, this is unknown.
     * @param interpretation the AIXM time slice interpretation to set.
     *        if in doubt, use "BASELINE"
     * @param sequence the AIXM time slice sequence number,
     *        if in doubt, specify 1
     * @param correction the AIXM time slice correction number,
     *        if in doubt, use  0
     * @return the corresponding AIXM airspace
     */
    static AirspaceType
    airspaceToAixm(Airspace             airspace,
                   String               codeSpace,
                   GregorianCalendar    validStart,
                   GregorianCalendar    validEnd,
                   String               interpretation,
                   long                 sequence,
                   long                 correction) {

        String idBase = airspace.getDesignator() != null
                      ? codeSpace + ":" + airspace.getDesignator() + ":"
                      : codeSpace + ":"
                                  + airspace.getName().replaceAll(" ", "")
                                  + ":";
        int    idIx   = 1;

        AirspaceType at = aixmFactory.createAirspaceType();
        at.setId(idBase + Integer.toString(idIx++));

        CodeWithAuthorityType id = gmlFactory.createCodeWithAuthorityType();
        id.setCodeSpace(codeSpace);
        id.setValue(airspace.getDesignator() != null
                                              ? airspace.getDesignator()
                                              : airspace.getName());
        at.setIdentifier(id);

        AirspaceTimeSlicePropertyType sliceProp =
                            aixmFactory.createAirspaceTimeSlicePropertyType();
        AirspaceTimeSliceType slice = aixmFactory.createAirspaceTimeSliceType();
        slice.setId(idBase + Integer.toString(idIx++));

        // set the validity time period
        dateFormatter.setTimeZone(TimeZone.getTimeZone("UTC"));
        TimePositionType validityStart = gmlFactory.createTimePositionType();
        if (validStart != null) {
            validityStart.getValue().add(
                                    dateFormatter.format(validStart.getTime()));
        } else {
            validityStart.setIndeterminatePosition(
                                        TimeIndeterminateValueType.UNKNOWN);
        }

        TimePositionType validityEnd = gmlFactory.createTimePositionType();
        if (validEnd != null) {
            validityEnd.getValue().add(
                                    dateFormatter.format(validEnd.getTime()));
        } else {
            validityEnd.setIndeterminatePosition(
                                        TimeIndeterminateValueType.UNKNOWN);
        }

        TimePeriodType   validTime  = gmlFactory.createTimePeriodType();
        validTime.setBeginPosition(validityStart);
        validTime.setEndPosition(validityEnd);

        TimePrimitivePropertyType validTP =
                                gmlFactory.createTimePrimitivePropertyType();
        validTP.setAbstractTimePrimitive(
                                        gmlFactory.createTimePeriod(validTime));

        // set the type
        CodeAirspaceType type = aixmFactory.createCodeAirspaceType();
        type.setValue(airspace.getType());
        slice.setType(type);

        // set the designator
        CodeAirspaceDesignatorType designator =
                                aixmFactory.createCodeAirspaceDesignatorType();
        designator.setValue(airspace.getDesignator());
        slice.setDesignator(designator);
        CodeYesNoType yes = aixmFactory.createCodeYesNoType();
        yes.setValue("yes");
        slice.setDesignatorICAO(yes);

        // set the name
        TextNameType name = aixmFactory.createTextNameType();
        name.setValue(airspace.getName());
        slice.setAixmName(name);

        airspaceControlActivationToAixm(airspace, slice);

        // set remarks
        NotePropertyType remarks = aixmFactory.createNotePropertyType();
        NoteType note = aixmFactory.createNoteType();

        CodeNotePurposeType purpose = aixmFactory.createCodeNotePurposeType();
        purpose.setValue("REMARK");
        note.setPurpose(purpose);

        LinguisticNotePropertyType enNoteT =
                                aixmFactory.createLinguisticNotePropertyType();
        LinguisticNoteType enNote = aixmFactory.createLinguisticNoteType();
        TextNoteType tNote = aixmFactory.createTextNoteType();
        tNote.setLang("eng");
        tNote.setValue(airspace.getRemarks());
        enNote.setNote(tNote);
        enNoteT.setLinguisticNote(enNote);
        note.getTranslatedNote().add(enNoteT);

        remarks.setNote(note);
        slice.getAnnotation().add(remarks);

        // create & convert the airspace volume itself
        AirspaceVolumeType airspaceVolume =
                                        aixmFactory.createAirspaceVolumeType();

        airspaceLimitsToAixm(airspace, airspaceVolume);

        boundaryToAixm(airspace.getBoundary(), airspaceVolume);

        // package all the stuff into whatever AIXM needs
        AirspaceVolumePropertyType airspaceVolumeProp =
                                aixmFactory.createAirspaceVolumePropertyType();
        airspaceVolumeProp.setAirspaceVolume(airspaceVolume);

        AirspaceGeometryComponentType geometry =
                aixmFactory.createAirspaceGeometryComponentType();
        geometry.setTheAirspaceVolume(airspaceVolumeProp);

        AirspaceGeometryComponentPropertyType geometryProp =
                aixmFactory.createAirspaceGeometryComponentPropertyType();
        geometryProp.setAirspaceGeometryComponent(geometry);

        slice.getGeometryComponent().add(geometryProp);

        slice.setInterpretation(interpretation);
        slice.setSequenceNumber(sequence);
        slice.setCorrectionNumber(correction);

        // add the time slice to the airspace
        slice.setValidTime(validTP);
        sliceProp.setAirspaceTimeSlice(slice);

        at.getTimeSlice().add(sliceProp);

        return at;
    }

    /**
     * Set the airspace control type & activation type, based on heuristics
     * about the properties of the airspace.
     *
     * @param airspace the airspace to get the information from
     * @param slice the airspace time slice to set the data for
     */
    private static void
    airspaceControlActivationToAixm(Airspace              airspace,
                                    AirspaceTimeSliceType slice) {
        // set the control type
        CodeMilitaryOperationsType controlType =
                            aixmFactory.createCodeMilitaryOperationsType();

        if (airspace.getType() != null) {
            if (airspace.getType().startsWith("M")) {
                controlType.setValue("MIL");
            } else {
                controlType.setValue("CIVIL");
            }
            slice.setControlType(controlType);
        }

        if ("H24".equals(airspace.getActiveTime())) {
            CodeDayType day = aixmFactory.createCodeDayType();
            day.setValue("ANY");

            TimeType start = aixmFactory.createTimeType();
            start.setValue("00:00");

            TimeType end = aixmFactory.createTimeType();
            end.setValue("24:00");

            CodeTimeReferenceType tRef =
                                    aixmFactory.createCodeTimeReferenceType();
            tRef.setValue("UTC");

            TimesheetType ts = aixmFactory.createTimesheetType();
            ts.setDay(day);
            ts.setStartTime(start);
            ts.setEndTime(end);
            ts.setTimeReference(tRef);

            TimesheetPropertyType tsp =
                                    aixmFactory.createTimesheetPropertyType();
            tsp.setTimesheet(ts);

            AirspaceActivationType act =
                                    aixmFactory.createAirspaceActivationType();
            act.getTimeInterval().add(tsp);

            AirspaceActivationPropertyType actProp =
                            aixmFactory.createAirspaceActivationPropertyType();
            actProp.setAirspaceActivation(act);
            slice.getActivation().add(actProp);
        }

        CodeAirspaceActivityType actv =
                                aixmFactory.createCodeAirspaceActivityType();

        if (airspace.getRemarks() != null && !airspace.getRemarks().isEmpty()) {
            String remarks = airspace.getRemarks().toLowerCase();
            if (remarks.contains("nuclear")) {
                actv.setValue("NUCLEAR");
            } else if (remarks.contains("refine")) {
                actv.setValue("REFINERY");
            } else if (remarks.contains("chemic")) {
                actv.setValue("CHEMICAL");
            } else if (remarks.contains("fauna")) {
                actv.setValue("FAUNA");
            } else if (remarks.contains("bird")) {
                actv.setValue("BIRD");
            } else if (remarks.contains("glide")
                    || remarks.contains("gliding")) {
                actv.setValue("GLIDER");
            } else if (remarks.contains("milit")) {
                actv.setValue("MILOPS");
            } else if (remarks.contains("parachut")) {
                actv.setValue("PARACHUTE");
            } else if (remarks.contains("aerobat")) {
                actv.setValue("AEROBATICS");
            }

            if (actv.isSetValue()) {
                AirspaceActivationType act =
                                    aixmFactory.createAirspaceActivationType();
                act.setActivity(actv);

                AirspaceActivationPropertyType actProp =
                        aixmFactory.createAirspaceActivationPropertyType();
                actProp.setAirspaceActivation(act);
                slice.getActivation().add(actProp);
            }
        }
    }

    /**
     * Convert airspace vertical limits into an AIXM airspace volume.
     *
     * @param airspace the airspace to convert the limits for.
     * @param airspaceVolume the airspace volume to put the limits into
     */
    private static void airspaceLimitsToAixm(Airspace          airspace,
                                            AirspaceVolumeType airspaceVolume) {
        // set the lower limit
        ValDistanceVerticalType lowerLimit =
                                    aixmFactory.createValDistanceVerticalType();
        lowerLimit.setUom(airspace.getLowerLimit().getUom().toString());
        lowerLimit.setValue(
                    Double.toString(airspace.getLowerLimit().getElevation()));
        airspaceVolume.setLowerLimit(lowerLimit);

        CodeVerticalReferenceType lowerLimitRef =
                                  aixmFactory.createCodeVerticalReferenceType();
        lowerLimitRef.setValue(
                            airspace.getLowerLimit().getReference().toString());
        airspaceVolume.setLowerLimitReference(lowerLimitRef);


        // set the upper limit
        ValDistanceVerticalType upperLimit =
                                    aixmFactory.createValDistanceVerticalType();
        upperLimit.setUom(airspace.getUpperLimit().getUom().toString());
        upperLimit.setValue(
                    Double.toString(airspace.getUpperLimit().getElevation()));
        airspaceVolume.setUpperLimit(upperLimit);

        CodeVerticalReferenceType upperLimitRef =
                                  aixmFactory.createCodeVerticalReferenceType();
        upperLimitRef.setValue(
                            airspace.getUpperLimit().getReference().toString());
        airspaceVolume.setUpperLimitReference(upperLimitRef);
    }

    /**
     * Convert an airspace boundary into AIXM, by putting it into an
     * AIXM airspace volume.
     *
     * @param boundary the boundary to convert
     * @param airspaceVolume the airspace volume to put the results of the
     *        conversion into
     */
    private static void boundaryToAixm(Boundary           boundary,
                                       AirspaceVolumeType airspaceVolume) {

        CurveSegmentArrayPropertyType curveSegment =
                            gmlFactory.createCurveSegmentArrayPropertyType();

        // put the appropriate type into a curveSegment
        switch (boundary.getType()) {
        case RING:
            Ring r = (Ring) boundary;

            DirectPositionListType directPosList =
                                    gmlFactory.createDirectPositionListType();
            for (Point p : r.getPointList()) {
                directPosList.getValue().add(p.getLatitude());
                directPosList.getValue().add(p.getLongitude());
            }

            GeodesicStringType geoString =
                                        gmlFactory.createGeodesicStringType();
            geoString.setPosList(directPosList);

            curveSegment.getAbstractCurveSegment().add(
                            gmlFactory.createGeodesicString(geoString));
            break;

        case CIRCLE:
            Circle c = (Circle) boundary;

            DirectPositionType center = gmlFactory.createDirectPositionType();
            center.getValue().add(c.getCenter().getLatitude());
            center.getValue().add(c.getCenter().getLongitude());

            LengthType radius = gmlFactory.createLengthType();
            radius.setUom(c.getRadius().getUom().toString());
            radius.setValue(c.getRadius().getDistance());

            CircleByCenterPointType ccp =
                                    gmlFactory.createCircleByCenterPointType();
            ccp.setPos(center);
            ccp.setRadius(radius);

            curveSegment.getAbstractCurveSegment().add(
                              gmlFactory.createCircleByCenterPoint(ccp));
            break;

        default:
        }

        // put the curve segment into all the structure AIXM requires
        CurveType curve = gmlFactory.createCurveType();
        curve.setSegments(curveSegment);

        CurvePropertyType curveProp = gmlFactory.createCurvePropertyType();
        curveProp.setAbstractCurve(gmlFactory.createCurve(curve));

        RingType ring = gmlFactory.createRingType();
        ring.getCurveMember().add(curveProp);

        AbstractRingPropertyType abstractRingProp =
                                gmlFactory.createAbstractRingPropertyType();
        abstractRingProp.setAbstractRing(gmlFactory.createRing(ring));

        PolygonPatchType polygonPatch = gmlFactory.createPolygonPatchType();
        polygonPatch.setExterior(abstractRingProp);

        SurfacePatchArrayPropertyType patchArray =
                          gmlFactory.createSurfacePatchArrayPropertyType();
        patchArray.getAbstractSurfacePatch().add(
                            gmlFactory.createPolygonPatch(polygonPatch));

        SurfaceType surfaceType = aixmFactory.createSurfaceType();
        surfaceType.setSrsName("urn:ogc:def:crs:EPSG:4326");
        surfaceType.setPatches(gmlFactory.createPatches(patchArray));

        SurfacePropertyType surfacePropType =
                                    aixmFactory.createSurfacePropertyType();
        surfacePropType.setSurface(aixmFactory.createSurface(surfaceType));
        airspaceVolume.setHorizontalProjection(surfacePropType);
    }

    /**
     * Convert a list of airspaces into a list of AIXM Airspaces.
     *
     * @param airspaces the airspaces to convert
     * @param codeSpace the code space to use when generating ids.
     * @param interpretation the AIXM time slice interpretation to set.
     *        if in doubt, use "BASELINE"
     * @param validStart the beginning of the validity period for the
     *        aerospace features. if null, this is unknown.
     * @param validEnd the end of the validity period for the
     *        aerospace features. if null, this is unknown.
     * @param sequence the AIXM time slice sequence number,
     *        if in doubt, specify 1
     * @param correction the AIXM time slice correction number,
     *        if in doubt, use  0
     * @param aixmAirspaces the converted airspaces will be put into
     *        this list
     */
    public static void
    airspacesToAixm(List<Airspace>     airspaces,
                    String             codeSpace,
                    GregorianCalendar  validStart,
                    GregorianCalendar  validEnd,
                    String             interpretation,
                    long               sequence,
                    long               correction,
                    List<AirspaceType> aixmAirspaces) {

        for (Airspace ap : airspaces) {
            aixmAirspaces.add(airspaceToAixm(ap,
                                             codeSpace,
                                             validStart,
                                             validEnd,
                                             interpretation,
                                             sequence,
                                             correction));
        }
    }
}
